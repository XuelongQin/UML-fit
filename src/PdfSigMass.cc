/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 
#include "RooFit.h"

#include "Riostream.h" 

#include "PdfSigMass.h" 
#include "GBRMath.h"

#include "RooDataHist.h"
#include "TMatrixDSym.h"
#include "RooFitResult.h"
ClassImp(PdfSigMass) 

using namespace RooFit;

PdfSigMass::PdfSigMass(const char *name, const char *title, 
		     RooAbsReal& _m,
         	     RooAbsReal& _mean_rt  ,
         	     RooAbsReal& _sigma_rt1,
         	     RooAbsReal& _alpha_rt1,
         	     RooAbsReal& _alpha_rt2,
         	     RooAbsReal& _n_rt1    ,
         	     RooAbsReal& _n_rt2    ,
         	     RooAbsReal& _mean_wt  ,
         	     RooAbsReal& _sigma_wt1,
         	     RooAbsReal& _alpha_wt1,
         	     RooAbsReal& _alpha_wt2,
         	     RooAbsReal& _n_wt1    ,
         	     RooAbsReal& _n_wt2    ,
		     RooAbsReal& _mFrac    ,
		     RooAbsReal& _rtMassTerm,
		     RooAbsReal& _wtMassTerm
		     ) :
  RooAbsPdf(name,title), 
  m("m","m",this,_m),
  mean_rt("mean_rt"  , "mean_rt"  ,this,_mean_rt  ),
  sigma_rt1("sigma_rt1" , "sigma_rt1" ,this,_sigma_rt1 ),
  alpha_rt1("alpha_rt1", "alpha_rt1",this,_alpha_rt1),
  alpha_rt2("alpha_rt2", "alpha_rt2",this,_alpha_rt2),
  n_rt1("n_rt1"    , "n_rt1"    ,this,_n_rt1    ),
  n_rt2("n_rt2"    , "n_rt2"    ,this,_n_rt2    ),
  mean_wt("mean_wt"  , "mean_wt"  ,this,_mean_wt  ),
  sigma_wt1("sigma_wt1" , "sigma_wt1" ,this,_sigma_wt1 ),
  alpha_wt1("alpha_wt1", "alpha_wt1",this,_alpha_wt1),
  alpha_wt2("alpha_wt2", "alpha_wt2",this,_alpha_wt2),
  n_wt1("n_wt1"    , "n_wt1"    ,this,_n_wt1    ),
  n_wt2("n_wt2"    , "n_wt2"    ,this,_n_wt2    ),
  mFrac("mFrac","mFrac",this,_mFrac),
  rtMassTerm("rtMassTerm","rtMassTerm",this,_rtMassTerm),
  wtMassTerm("wtMassTerm","wtMassTerm",this,_wtMassTerm)
{
}

PdfSigMass::PdfSigMass(const char *name, const char *title, 
		     RooAbsReal& _m,
         	     RooAbsReal& _mean_rt  ,
         	     RooAbsReal& _sigma_rt1,
         	     RooAbsReal& _sigma_rt2 ,
         	     RooAbsReal& _alpha_rt1,
         	     RooAbsReal& _alpha_rt2,
         	     RooAbsReal& _n_rt1    ,
         	     RooAbsReal& _n_rt2    ,
         	     RooAbsReal& _f1rt  ,
         	     RooAbsReal& _mean_wt  ,
         	     RooAbsReal& _sigma_wt1,
         	     RooAbsReal& _alpha_wt1,
         	     RooAbsReal& _alpha_wt2,
         	     RooAbsReal& _n_wt1    ,
         	     RooAbsReal& _n_wt2    ,
		     RooAbsReal& _mFrac,
		     RooAbsReal& _rtMassTerm,
		     RooAbsReal& _wtMassTerm
		     ) :
  RooAbsPdf(name,title), 
  m("m","m",this,_m),
  mean_rt("mean_rt", "mean_rt"  ,this,_mean_rt),
  sigma_rt1("sigma_rt1", "sigma_rt1" ,this,_sigma_rt1),
  sigma_rt2("sigma_rt2", "sigma_rt2" ,this,_sigma_rt2),
  alpha_rt1("alpha_rt1", "alpha_rt1",this,_alpha_rt1),
  alpha_rt2("alpha_rt2", "alpha_rt2",this,_alpha_rt2),
  n_rt1("n_rt1", "n_rt1",this,_n_rt1),
  n_rt2("n_rt2", "n_rt2",this,_n_rt2),
  f1rt("f1rt", "f1rt",this,_f1rt),
  mean_wt("mean_wt"  , "mean_wt"  ,this,_mean_wt  ),
  sigma_wt1("sigma_wt1" , "sigma_wt1" ,this,_sigma_wt1 ),
  alpha_wt1("alpha_wt1", "alpha_wt1",this,_alpha_wt1),
  alpha_wt2("alpha_wt2", "alpha_wt2",this,_alpha_wt2),
  n_wt1("n_wt1"    , "n_wt1"    ,this,_n_wt1    ),
  n_wt2("n_wt2"    , "n_wt2"    ,this,_n_wt2    ),
  mFrac("mFrac","mFrac",this,_mFrac),
  rtMassTerm("rtMassTerm","rtMassTerm",this,_rtMassTerm),
  wtMassTerm("wtMassTerm","wtMassTerm",this,_wtMassTerm)
{
}



PdfSigMass::PdfSigMass(const PdfSigMass& other, const char* name) :  
  RooAbsPdf(other,name), 
  m("m",this,other.m),
  mean_rt("mean_rt",this,other.mean_rt),
  sigma_rt1("sigma_rt1",this,other.sigma_rt1),
  sigma_rt2("sigma_rt2",this,other.sigma_rt2),
  alpha_rt1("alpha_rt1",this,other.alpha_rt1),
  alpha_rt2("alpha_rt2",this,other.alpha_rt2),
  n_rt1("n_rt1",this,other.n_rt1),
  n_rt2("n_rt2",this,other.n_rt2),
  f1rt("f1rt",this,other.f1rt),
  mean_wt("mean_wt",this,other.mean_wt),
  sigma_wt1("sigma_wt1",this,other.sigma_wt1),
  alpha_wt1("alpha_wt1",this,other.alpha_wt1),
  alpha_wt2("alpha_wt2",this,other.alpha_wt2),
  n_wt1("n_wt1",this,other.n_wt1),
  n_wt2("n_wt2",this,other.n_wt2),
  mFrac("mFrac",this,other.mFrac),
  rtMassTerm("rtMassTerm", this, other.rtMassTerm),
  wtMassTerm("wtMassTerm", this, other.wtMassTerm)
{
}



Double_t PdfSigMass::evaluate() const 
{
  double mCT = ((RooAbsPdf&)(rtMassTerm.arg())).getVal();
  double mWT = ((RooAbsPdf&)(wtMassTerm.arg())).getVal();
  
  return mCT + (mFrac)*mWT;

}

namespace {
  Bool_t fullRangeMass(const RooRealProxy& x ,const char* range)
  {
    // set accepted integration range for mass variables
    return range == 0 || strlen(range) == 0
      ? std::fabs(x.min() - 5.) < 1.e-5 && std::fabs(x.max() - 5.6) < 1.e-5
      : std::fabs(x.min(range) - 5.) < 1.e-5 && std::fabs(x.max(range) - 5.6) < 1.e-5;
  }
}


Int_t PdfSigMass::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const
{
  if ( matchArgs(allVars,analVars,m) ){
    if ( fullRangeMass(m,rangeName) ) {
      return 1 ;
    }
  }
  return 0 ;
}

Double_t PdfSigMass::analyticalIntegral(Int_t code, const char* rangeName) const
{
  assert(code>0 && code<2) ;
  
  RooAbsReal & marg = (RooAbsReal&)m.arg();
  
  RooAbsReal & rtMass = (RooAbsReal&)rtMassTerm.arg();
  double rtMassIntegral = ((RooAbsReal* )rtMass.createIntegral(marg))->getVal();
  //std::cout <<  "PdfSigMass:analyticalIntegral:rtMassIntegral  " << rtMassIntegral << std::endl;
  
  RooAbsReal & wtMass = (RooAbsReal&)wtMassTerm.arg();
  double wtMassIntegral = ((RooAbsReal* )wtMass.createIntegral(marg))->getVal();
  //std::cout <<  "PdfSigMass:analyticalIntegral:wtMassIntegral  " << wtMassIntegral << std::endl;

  double theIntegral = rtMassIntegral + mFrac*wtMassIntegral  ;
  //std::cout <<  "integral: " << theIntegral << std::endl;

  return theIntegral ;

}
